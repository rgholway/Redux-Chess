[{"/Users/richardholway/challenges/redux-second-chess/src/serviceWorker.js":"1","/Users/richardholway/challenges/redux-second-chess/src/App.js":"2","/Users/richardholway/challenges/redux-second-chess/src/features/chess/BoardContainer.js":"3","/Users/richardholway/challenges/redux-second-chess/src/features/chess/Board.js":"4","/Users/richardholway/challenges/redux-second-chess/src/features/chess/chessSlice.js":"5","/Users/richardholway/challenges/redux-second-chess/src/features/chess/ChessConstants.js":"6","/Users/richardholway/challenges/redux-second-chess/src/app/store.js":"7","/Users/richardholway/challenges/redux-second-chess/src/features/chess/Piece.js":"8","/Users/richardholway/challenges/redux-second-chess/src/features/chess/PieceConstants.js":"9","/Users/richardholway/challenges/redux-second-chess/src/features/chess/PromotionModal.js":"10","/Users/richardholway/challenges/redux-second-chess/src/index.js":"11"},{"size":5141,"mtime":1609541742691,"results":"12","hashOfConfig":"13"},{"size":214,"mtime":1609904474860,"results":"14","hashOfConfig":"13"},{"size":2,"mtime":1609552165141,"results":"15","hashOfConfig":"13"},{"size":3686,"mtime":1610413886201,"results":"16","hashOfConfig":"13"},{"size":8604,"mtime":1610417112624,"results":"17","hashOfConfig":"13"},{"size":16266,"mtime":1610222867568,"results":"18","hashOfConfig":"13"},{"size":192,"mtime":1609711368083,"results":"19","hashOfConfig":"13"},{"size":514,"mtime":1610219694312,"results":"20","hashOfConfig":"13"},{"size":16982,"mtime":1610418063237,"results":"21","hashOfConfig":"13"},{"size":1005,"mtime":1609907916397,"results":"22","hashOfConfig":"13"},{"size":644,"mtime":1609541742689,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"1d4jrg5",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"42","messages":"43","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/richardholway/challenges/redux-second-chess/src/serviceWorker.js",[],["49","50"],"/Users/richardholway/challenges/redux-second-chess/src/App.js",[],"/Users/richardholway/challenges/redux-second-chess/src/features/chess/BoardContainer.js",[],"/Users/richardholway/challenges/redux-second-chess/src/features/chess/Board.js",["51","52","53","54"],"import React, { useEffect, useState } from \"react\";\nimport { connect, useDispatch } from \"react-redux\";\nimport { bindActionCreators } from \"redux\";\nimport Piece from \"./Piece\";\nimport PromotionModal from \"./PromotionModal\";\nimport { selectBox } from \"./chessSlice\";\nimport { highlightPotentialMoves } from \"./chessSlice\";\n\nconst Board = ({ boxes, selectedPiece, turn, userTeam, preMove}) => {\n  const dispatch = useDispatch();\n\n  const handleClick = (id, isPotentialMove) => {\n    // Weird logic here because right now we are both teams. Once Stockfish is set up we will set the\n    //user team and the logic will be simpler\n    const selectedBox = selectBox(boxes, id)\n    console.log(selectedBox?.piece)\n      if (selectedPiece?.team === turn && isPotentialMove) {\n        dispatch({ type: \"chess/movePiece\", payload: id });\n      } else if (selectedBox?.piece?.team === turn) {\n        dispatch({ type: \"chess/highlightPotentialMoves\", payload: id });\n      } else if (preMove?.selectedPiece || selectedBox?.piece?.team === 2) {\n        dispatch({ type: \"chess/preMovePiece\", payload: {selectedPiece: selectedBox?.piece?.id, selectedSquare: selectedBox?.id} });\n      }\n}\n\n  const handleSelectPromotion = (pieceName, id) => {\n    dispatch({ type: \"chess/promotePiece\", payload: { pieceName, id } });\n  };\n\n  const boxMap = boxes?.map((box) => {\n    //Find a better way to overlay/change the background\n    const preMoveStyle = box?.hasPiece ? '-100%' : '0%'\n    return (\n      <>\n        <div\n          key={box?.id}\n          id={box?.id}\n          className={box?.className}\n          onClick={() => handleClick(box?.id, box?.isPotentialMove)}\n          name={box?.name}\n          style={{\n            backgroundColor: box?.style?.backgroundColor,\n            borderTopLeftRadius: box?.style?.borderTopLeftRadius,\n            borderTopRightRadius: box?.style?.borderTopRightRadius,\n            borderBottomRightRadius: box?.style?.borderBottomRightRadius,\n            borderBottomLeftRadius: box?.style?.borderBottomLeftRadius,\n          }}\n          hasPiece={box?.hasPiece}\n        >\n          {box?.isPromotion && (\n            <PromotionModal\n              team={box?.piece?.team}\n              id={box?.id}\n              handleSelectPromotion={handleSelectPromotion}\n            />\n          )}\n          {box?.hasPiece && (\n            <Piece\n              key={box?.id}\n              id={box?.id}\n              highlightPotentialMoves={highlightPotentialMoves}\n              pieceName={box?.piece?.pieceName}\n              className={box?.piece?.className}\n              hasMoved={box?.piece?.hasMoved}\n              isAttacked={box?.piece?.isAttacked}\n              potentialMoves={box?.piece?.potentialMoves}\n              isKing={box?.piece?.isKing}\n              isKing={box?.piece?.isHorse}\n              isProtectingKing={box?.piece?.isProtectingKing}\n              isAttackingKing={box?.piece?.isAttackingKing}\n              rules={box?.piece?.rules}\n              team={box?.piece?.team}\n            />\n          )}\n          {box?.isPotentialMove && <div className=\"PotentialMove\" />}\n          {box?.id === preMove?.selectedPiece && <div className=\"PreMovePiece\" />}\n          {box?.id === preMove?.selectedMove && <div className=\"PreMoveBox\" style={{marginTop: preMoveStyle }} />}\n        </div>\n      </>\n    );\n  });\n\n  return <div className=\"board\">{boxMap}</div>;\n};\n\nconst mapStateToProps = (state) => {\n  return {\n    boxes: state?.state?.boxes,\n    selectedPiece: state?.state?.selectedPiece,\n    turn: state?.state?.turn,\n    userTeam: state?.state?.user?.team,\n    preMove: state?.state?.preMove,\n  };\n};\n\nexport default connect(mapStateToProps)(Board);\n","/Users/richardholway/challenges/redux-second-chess/src/features/chess/chessSlice.js",["55"],"/Users/richardholway/challenges/redux-second-chess/src/features/chess/ChessConstants.js",["56"],"/Users/richardholway/challenges/redux-second-chess/src/app/store.js",[],"/Users/richardholway/challenges/redux-second-chess/src/features/chess/Piece.js",["57","58","59"],"/Users/richardholway/challenges/redux-second-chess/src/features/chess/PieceConstants.js",["60","61","62","63","64","65","66","67"],"import {selectBox} from \"./chessSlice\"\n\nexport const rules = {\n  WhitePawn: {\n    movement: {\n      firstMove: [\"DOWN1\", \"DOWN2\"],\n      move: [\"DOWN1\"],\n      attack: [\"DIAGONAL_RIGHT_DOWN\", \"DIAGONAL_LEFT_DOWN\"],\n    },\n  },\n  BlackPawn: {\n    movement: {\n      firstMove: [\"UP1\", \"UP2\"],\n      move: [\"UP1\"],\n      attack: [\"DIAGONAL_RIGHT_UP\", \"DIAGONAL_LEFT_UP\"],\n    },\n  },\n  Bishop: {\n    movement: {\n      move: [\n        \"DIAGONAL_RIGHT_DOWN\",\n        \"DIAGONAL_LEFT_DOWN\",\n        \"DIAGONAL_RIGHT_UP\",\n        \"DIAGONAL_LEFT_UP\"\n      ],\n      badMoves: {\n        isRightWall: [\"DIAGONAL_RIGHT_DOWN\", \"DIAGONAL_LEFT_UP\"],\n        isLeftWall: [\"DIAGONAL_LEFT_DOWN\", \"DIAGONAL_RIGHT_UP\"],\n        isBottomRow: [\"DIAGONAL_RIGHT_UP\", \"DIAGONAL_LEFT_UP\"],\n        isTopRow: [\"DIAGONAL_RIGHT_DOWN\", \"DIAGONAL_LEFT_DOWN\"]\n      }\n    },\n  },\n  Knight: {\n    movement: {\n      move: [\n        \"DOWN17\",\n        \"DOWN15\",\n        \"DOWN6\",\n        \"DOWN10\",\n        \"UP17\",\n        \"UP15\",\n        \"UP6\",\n        \"UP10\",\n      ],\n      badMoves: {\n        isLeftWall: [\n            \"UP15\",\n            \"UP6\",\n            \"DOWN10\",\n            \"DOWN17\"\n        ],\n        isRightWall: [\n            \"DOWN15\",\n            \"DOWN6\",\n            \"UP10\",\n            \"UP17\"\n        ],\n        isNextToRightWall: [\n          \"DOWN6\",\n          \"UP10\"\n        ],\n        isNextToLeftWall: [\n          \"UP6\",\n          \"DOWN10\"\n        ]\n      }\n    },\n  },\n  Rook: {\n    movement: {\n      move: [[\"RIGHT1\"], [\"LEFT1\"], [\"UP1\"], [\"DOWN1\"]],\n      badMoves: {\n        isRightWall: \"RIGHT1\",\n        isLeftWall: \"LEFT1\",\n        isBottomRow: \"UP1\",\n        isTopRow: \"DOWN1\"\n      }\n    },\n  },\n  Queen: {\n    movement: {\n      move: [\n        \"RIGHT1\",\n        \"LEFT1\",\n        \"UP1\",\n        \"DOWN1\",\n        \"DIAGONAL_RIGHT_UP\",\n        \"DIAGONAL_LEFT_UP\",\n        \"DIAGONAL_RIGHT_DOWN\",\n        \"DIAGONAL_LEFT_DOWN\",\n      ],\n      badMoves: {\n        isRightWall: [\"RIGHT1\", \"DIAGONAL_RIGHT_DOWN\", \"DIAGONAL_LEFT_UP\"],\n        isLeftWall: [\"LEFT1\", \"DIAGONAL_LEFT_DOWN\", \"DIAGONAL_RIGHT_UP\"],\n        isTopRow: [\"DIAGONAL_RIGHT_DOWN\", \"DIAGONAL_LEFT_DOWN\", \"DOWN1\"],\n        isBottomRow: [\"DIAGONAL_RIGHT_UP\", \"DIAGONAL_LEFT_UP\", \"UP1\"]\n      }\n    },\n  },\n  King: {\n    movement: {\n      move: [\n        \"RIGHT1\",\n        \"LEFT1\",\n        \"UP1\",\n        \"DOWN1\",\n        \"DIAGONAL_RIGHT_UP\",\n        \"DIAGONAL_LEFT_UP\",\n        \"DIAGONAL_RIGHT_DOWN\",\n        \"DIAGONAL_LEFT_DOWN\",\n      ],\n      specialMoves: {\n        queenSideCastle: \"QueenSideCastle\",\n        kingSideCastle: \"KingSideCastle\",\n      },\n      attackedFrom: [\n        \"DOWN17\",\n        \"DOWN15\",\n        \"DOWN6\",\n        \"DOWN10\",\n        \"UP17\",\n        \"UP15\",\n        \"UP6\",\n        \"UP10\"\n      ],\n      badMoves: {\n        isRightWall: [\"RIGHT1\", \"DIAGONAL_RIGHT_DOWN\", \"DIAGONAL_LEFT_UP\",\"DOWN15\",\n        \"DOWN6\",\n        \"UP10\",\n        \"UP17\" ],\n        isLeftWall: [\"LEFT1\", \"DIAGONAL_LEFT_DOWN\", \"DIAGONAL_RIGHT_UP\", \"UP15\",\n        \"UP6\",\n        \"DOWN10\",\n        \"DOWN17\"],\n        isTopRow: [\"DIAGONAL_RIGHT_DOWN\", \"DIAGONAL_LEFT_DOWN\", \"DOWN1\"],\n        isBottomRow: [\"DIAGONAL_RIGHT_UP\", \"DIAGONAL_LEFT_UP\", \"UP1\"],\n        isNextToRightWall: [\n          \"DOWN6\",\n          \"UP10\"\n        ],\n        isNextToLeftWall: [\n          \"UP6\",\n          \"DOWN10\"\n        ]\n      },\n    },\n  },\n};\n\nconst movement = {\n  DOWN1: -8,\n  DOWN2: -16,\n  UP1: 8,\n  UP2: 16,\n  DOWN17: -17,\n  DOWN15: -15,\n  DOWN6: -6,\n  DOWN10: -10,\n  UP17: 17,\n  UP15: 15,\n  UP6: 6,\n  UP10: 10,\n  DIAGONAL_LEFT_DOWN: -9,\n  DIAGONAL_RIGHT_DOWN: -7,\n  DIAGONAL_LEFT_UP: +9,\n  DIAGONAL_RIGHT_UP: +7,\n  RIGHT1: +1,\n  LEFT1: -1,\n};\n\nexport const calculateCheck = (boxes, turn) => {\n  let blackKing;\n  let whiteKing;\n  let sameTeam = []\n  let otherTeam = []\n  let walls = []\n  boxes.map((box) => {\n    if (box.piece.team === turn) {\n      sameTeam.push(box.id);\n    } else if (box.hasPiece && box.piece.team !== turn) {\n      otherTeam.push(box.id);\n    }\n    if (box.isWall) {\n      walls.push(box.id);\n    }\n    if (box?.piece?.className === 'WhiteKing') {\n      whiteKing = box?.piece\n    }\n\n    if (box?.piece?.className === 'BlackKing') {\n      blackKing = box?.piece\n    }\n  });\n  const enemyKing = turn === 2 ? blackKing : whiteKing\n  const attackingMoves = teamMoves(sameTeam, boxes)\n  const moves = attackingMoves?.moves?.filter(move => move <= 63 && move >= 0)\n  const pieceMoves = attackingMoves?.pieceMoves\n  const defendingKing = checkDefendingKing(enemyKing, boxes, otherTeam)\n  let piecesDefendingKingFromCheck = []\n  let attackingPieces = []\n  defendingKing?.forEach(piece => {\n    pieceMoves?.forEach(move => {\n      if (move?.potentialMoves?.includes(piece?.piece)) {\n        if (!move?.piece?.isPawn && !move?.piece?.isHorse && !move?.piece?.isKing) {\n          piecesDefendingKingFromCheck?.push(piece)\n        }\n      }\n    })\n  })\n  pieceMoves?.forEach(move => {\n    if (move?.potentialMoves?.includes(enemyKing?.id)) {\n      attackingPieces?.push(move?.piece?.id)\n    }\n  })\n  return {attackingPieces, piecesDefendingKingFromCheck}\n}\n\nconst checkDefendingKing = (king, boxes, otherTeam) => {\n  const square = king?.id\n  const moves = [\n    \"RIGHT1\",\n    \"LEFT1\",\n    \"UP1\",\n    \"DOWN1\",\n    \"DIAGONAL_RIGHT_UP\",\n    \"DIAGONAL_LEFT_UP\",\n    \"DIAGONAL_RIGHT_DOWN\",\n    \"DIAGONAL_LEFT_DOWN\",\n  ]\n  let piecesDefendingKing = []\n  for (var i = 0; i < moves.length; i++) {\n    let possibleMovement = square;\n\n    const move = moves[i];\n    for (var j = 0; j < 7; j++) {\n      possibleMovement += movement[move]\n      if (possibleMovement > -1 && possibleMovement < 64) {\n      }\n      if (otherTeam?.includes(possibleMovement)) {\n\n        // Select enemy piece and dont add if pawn/horse/king\n        //Check horse seperately but change moves to horse moves only\n        //THis will work\n\n        //May need to investigate why extra pieces are being added to attack. Check King is true\n          piecesDefendingKing?.push({piece: possibleMovement, move})\n          break\n      }\n    }\n  }\n  return piecesDefendingKing\n}\n\n\nexport const calculatePotentialMoves = (piece, boxes, isCheckingKing) => {\n  let options = [];\n\n  if (!piece) {\n    return []\n  }\n  //Piece Movement\n  const pieceRules = rules[piece.pieceName];\n  const moves = pieceRules?.movement?.move;\n  const badMoves = pieceRules?.movement?.badMoves;\n  let filteredMoves = [...moves]\n\n  //special Pieces\n  let whiteKing = ''\n  let blackKing = ''\n\n  //Piece Position\n  const isRightWall = (piece.id + 1) % 8 === 0;\n  const isLeftWall = (piece.id) % 8 === 0 || piece.id === 0;\n  const isNextToLeftWall = piece.id - 1 === 0 || (piece.id - 1) % 8 === 0;\n  const isNextToRightWall = (piece.id + 2) % 8 === 0;\n  const isBottomRow = piece.id > 55\n  const isTopRow = piece.id < 8\n  const isPieceOnWall = isRightWall || isLeftWall || isTopRow || isBottomRow\n\n  //Board Logic\n  let potentialMoves = [];\n  let boardMoves = [];\n  let otherPieces = [];\n  let walls = [];\n  let attackingPieces = [];\n  boxes.map((box) => {\n    if (box.piece.team === piece.team) {\n      boardMoves.push(box.id);\n    } else if (box.hasPiece) {\n      otherPieces.push(box.id);\n    }\n    if (box?.piece?.isAttackingKing) {\n      console.log(box)\n      attackingPieces?.push(box?.id)\n    }\n    if (box.isWall) {\n      walls.push(box.id);\n    }\n    if (box?.piece?.className === 'WhiteKing') {\n      whiteKing = box?.piece\n    }\n    if (box?.piece?.className === 'BlackKing') {\n      blackKing = box?.piece\n    }\n  });\n\n  const enemyKing = piece.team === 2 ? blackKing : whiteKing\n  filteredMoves = filterMoves(moves, badMoves, isRightWall, isLeftWall, isTopRow, isBottomRow)\n  if (piece?.isProtectingKing) {\n    return calculateProtectedMoves(boardMoves,  otherPieces, filteredMoves, piece, pieceRules)\n  }\n\n  if (piece.isPawn) {\n    return potentialMoves = calculatePawn(piece, boardMoves, otherPieces, walls, isCheckingKing)\n  }\n\n  if (piece?.isKing ){\n    filteredMoves = filterMoves(moves, badMoves, isRightWall, isLeftWall, isTopRow, isBottomRow, isNextToLeftWall, isNextToRightWall)\n    return calculateKing(piece.id, filteredMoves, boardMoves, otherPieces, walls, isPieceOnWall, boxes, piece.team, isCheckingKing)\n  }\n\n  if (piece.isHorse) {\n    filteredMoves = filterMoves(moves, badMoves, isRightWall, isLeftWall, isTopRow, isBottomRow, isNextToLeftWall, isNextToRightWall)\n    return calculateHorse(piece.id, filteredMoves, boardMoves, otherPieces)\n  }\n\n    return calculatePiece(piece.id, filteredMoves, boardMoves, otherPieces, walls, isPieceOnWall, enemyKing, isCheckingKing)\n  };\n\n  const isWall = (square, walls) => {\n    return walls.includes(square);\n  };\n\n  const calculateKing = (square, moves, sameTeam, otherTeam, walls, isPieceOnWall, boxes, team, isCheckingKing) => {\n    let potentialMoves = []\n    let allEnemyTeamMoves = []\n    if (!isCheckingKing) {\n      allEnemyTeamMoves = teamMoves(otherTeam, boxes)?.moves\n    }\n      for (var i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const possibleMovement = square + movement[move]\n        if (!sameTeam.includes(possibleMovement)) {\n          if (!allEnemyTeamMoves?.includes(possibleMovement)) {\n              potentialMoves.push(possibleMovement)\n            }\n          }\n        }\n        return potentialMoves\n      }\n\n  const teamMoves = (team, boxes) => {\n    let moves = []\n    let pieceMoves = []\n    team?.forEach(piece => {\n      const selectedPiece = selectBox(boxes, piece)?.piece\n        const calculatedPotentialMoves = calculatePotentialMoves(selectedPiece, boxes, true)\n        pieceMoves = pieceMoves.concat({potentialMoves: calculatedPotentialMoves, piece: selectedPiece})\n        moves = moves.concat(calculatedPotentialMoves)\n    })\n    return {moves, pieceMoves}\n  }\n\n  const filterMoves = (moves, badMoves, isRightWall, isLeftWall, isTopRow, isBottomRow, isNextToLeftWall, isNextToRightWall) => {\n    let disallowedMoves = []\n    if (isRightWall) {\n      if (isTopRow) {\n        disallowedMoves = badMoves?.isRightWall.concat(badMoves?.isTopRow)\n        return moves?.filter((move) => !disallowedMoves?.includes(move))\n      } else if (isBottomRow) {\n        disallowedMoves = badMoves?.isRightWall.concat(badMoves?.isBottomRow)\n        return moves?.filter((move) => !disallowedMoves?.includes(move))\n      } else {\n        const check = moves?.filter((move) => !badMoves?.isRightWall?.includes(move))\n        return moves?.filter((move) => !badMoves?.isRightWall?.includes(move))\n      }\n    } else if (isLeftWall) {\n      if (isTopRow) {\n        disallowedMoves = badMoves?.isLeftWall.concat(badMoves?.isTopRow)\n        return moves?.filter((move) => !disallowedMoves?.includes(move))\n      } else if (isBottomRow) {\n        disallowedMoves = badMoves?.isLeftWall.concat(badMoves?.isBottomRow)\n        return moves?.filter((move) => !disallowedMoves?.includes(move))\n      } else {\n        return moves?.filter((move) => !badMoves?.isLeftWall?.includes(move))\n      }\n    } else if (isTopRow) {\n      if (isNextToLeftWall) {\n        disallowedMoves = badMoves?.isNextToLeftWall.concat(badMoves?.isTopRow)\n        return moves?.filter((move) => !disallowedMoves?.includes(move))\n      } else if (isNextToRightWall) {\n        disallowedMoves = badMoves?.isNextToRightWall.concat(badMoves?.isTopRow)\n        return moves?.filter((move) => !disallowedMoves?.includes(move))\n      }\n      return moves?.filter((move) => !badMoves?.isTopRow?.includes(move))\n    } else if (isBottomRow) {\n      if (isNextToLeftWall) {\n        disallowedMoves = badMoves?.isNextToLeftWall.concat(badMoves?.isBottomRow)\n        return moves?.filter((move) => !disallowedMoves?.includes(move))\n      } else if (isNextToRightWall) {\n        disallowedMoves = badMoves?.isNextToRightWall.concat(badMoves?.isBottomRow)\n        return moves?.filter((move) => !disallowedMoves?.includes(move))\n      }\n      return moves?.filter((move) => !badMoves?.isBottomRow?.includes(move))\n    } else if (isNextToLeftWall) {\n      return moves?.filter((move) => !badMoves?.isNextToLeftWall?.includes(move))\n    } else if (isNextToRightWall) {\n      return moves?.filter((move) => !badMoves?.isNextToRightWall?.includes(move))\n    } else {\n      return moves\n    }\n  }\n\n  const calculateProtectedMoves = (sameTeam,  otherPieces, move, piece, rules) => {\n    const canMove = rules?.movement?.move?.includes(move[0]) || rules?.movement?.attack?.includes(move[0])\n    console.log(move)\n    let potentialMovement = [];\n    const attackedFrom = piece?.isProtectingKing\n    const square = piece?.id\n\n    let possibleMovement = square\n    let backwardsMovement = square\n    console.log(movement[move])\n    if (canMove) {\n      for (var i = 0; i < 7; i++) {\n        possibleMovement += movement[move[i]]\n        backwardsMovement += movement[move[i]]\n        console.log(possibleMovement)\n        if (!sameTeam?.includes(possibleMovement)) {\n          if (piece?.isHorse) {\n            break\n          }\n          if (piece?.isPawn) {\n\n            potentialMovement?.push(possibleMovement)\n            break\n          }\n          if (otherPieces?.includes(possibleMovement)) {\n            potentialMovement?.push(possibleMovement)\n            break\n          }\n\n            potentialMovement?.push(possibleMovement)\n        }\n\n      else {\n        if (!sameTeam?.includes(backwardsMovement)) {\n          if (piece?.isHorse) {\n            break\n          }\n          if (piece?.isPawn) {\n            break\n          }\n          if (otherPieces?.includes(backwardsMovement)) {\n            potentialMovement?.push(backwardsMovement)\n            break\n          }\n\n            potentialMovement?.push(backwardsMovement)\n        }\n      }\n    }\n      return potentialMovement\n  }\n\n  }\n\n  const calculatePiece = (square, moves, sameTeam, otherTeam, walls, isPieceOnWall, enemyKing, isCheckingKing ) => {\n    let potentialMoves = []\n    for (var i = 0; i < moves.length; i++) {\n      let possibleMovement = square;\n      const move = moves[i];\n      const isDiagonal = move[0] === 'DIAGONAL_LEFT_UP' || move[0] === 'DIAGONAL_RIGHT_UP' || move[0] === 'DIAGONAL_LEFT_DOWN' || move[0] === 'DIAGONAL_RIGHT_DOWN'\n      for (var j = 0; j < 7; j++) {\n        possibleMovement += movement[move]\n        if (!sameTeam.includes(possibleMovement)) {\n          if (otherTeam.includes(possibleMovement)) {\n            if (enemyKing?.id === possibleMovement && isCheckingKing) {\n              potentialMoves.push(possibleMovement)\n            } else {\n              potentialMoves.push(possibleMovement)\n              break\n            }\n          }\n          if (!isPieceOnWall) {\n            if (isWall(possibleMovement, walls)) {\n              potentialMoves.push(possibleMovement)\n              break\n            }\n          } else {\n            if (otherTeam.includes(possibleMovement)) {\n              if (enemyKing?.id === possibleMovement && isCheckingKing) {\n                potentialMoves.push(possibleMovement)\n              } else {\n                potentialMoves.push(possibleMovement)\n                break\n              }\n            }\n            if (isDiagonal) {\n              if (isWall(possibleMovement, walls)) {\n                potentialMoves.push(possibleMovement)\n                break\n              }\n            }\n          }\n          potentialMoves.push(possibleMovement)\n        } else {\n          break\n        }\n      }\n    }\n    return potentialMoves\n  }\n\nconst calculatePawn = (piece, boardMoves, otherPieces, walls, isCheckingKing) => {\n  let options = [];\n  const pieceRules = rules[piece.pieceName];\n  const firstMove = pieceRules?.movement?.firstMove;\n  const attackMoves = pieceRules?.movement?.attack;\n  const moves = pieceRules?.movement?.move;\n  if (!piece?.hasMoved) {\n    for (var i = 0; i < firstMove.length; i++) {\n      const move = firstMove[i];\n      if (\n        !boardMoves.includes(piece.id + movement[move]) &&\n        !otherPieces.includes(piece.id + movement[move])\n      ) {\n        options.push(piece.id + movement[move]);\n      } else {\n        break;\n      }\n    }\n  }\n  for (var i = 0; i < attackMoves.length; i++) {\n    const attack = attackMoves[i];\n    const move = moves[i];\n    if (otherPieces.includes(piece.id + movement[attack]) || isCheckingKing) {\n      if (!boardMoves.includes(piece.id + movement[move]) && !isCheckingKing) {\n        options.push(piece.id + movement[move]);\n      }\n      options.push(piece.id + movement[attack]);\n    } else if (\n      !boardMoves.includes(piece.id + movement[move]) &&\n      !otherPieces.includes(piece.id + movement[move])\n    ) {\n      options.push(piece.id + movement[move]);\n    }\n  }\n  return options;\n};\n\nconst calculateHorse = (square, moves, sameTeam, otherTeam) => {\n    let options = []\n  for (var i = 0; i < moves.length; i++) {\n    const move = moves[i];\n    const possibleMovement = square + movement[move];\n    if (!sameTeam.includes(possibleMovement)) {\n      options.push(possibleMovement);\n    }\n  }\n  return options;\n};\n","/Users/richardholway/challenges/redux-second-chess/src/features/chess/PromotionModal.js",[],"/Users/richardholway/challenges/redux-second-chess/src/index.js",[],{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","replacedBy":"71"},{"ruleId":"72","severity":1,"message":"73","line":1,"column":17,"nodeType":"74","messageId":"75","endLine":1,"endColumn":26},{"ruleId":"72","severity":1,"message":"76","line":1,"column":28,"nodeType":"74","messageId":"75","endLine":1,"endColumn":36},{"ruleId":"72","severity":1,"message":"77","line":3,"column":10,"nodeType":"74","messageId":"75","endLine":3,"endColumn":28},{"ruleId":"78","severity":1,"message":"79","line":68,"column":15,"nodeType":"80","endLine":68,"endColumn":43},{"ruleId":"72","severity":1,"message":"81","line":2,"column":8,"nodeType":"74","messageId":"75","endLine":2,"endColumn":14},{"ruleId":"72","severity":1,"message":"82","line":132,"column":7,"nodeType":"74","messageId":"75","endLine":132,"endColumn":16},{"ruleId":"72","severity":1,"message":"83","line":2,"column":10,"nodeType":"74","messageId":"75","endLine":2,"endColumn":15},{"ruleId":"72","severity":1,"message":"84","line":18,"column":9,"nodeType":"74","messageId":"75","endLine":18,"endColumn":17},{"ruleId":"72","severity":1,"message":"85","line":20,"column":7,"nodeType":"74","messageId":"75","endLine":20,"endColumn":21},{"ruleId":"86","severity":1,"message":"87","line":178,"column":19,"nodeType":"88","messageId":"89","endLine":178,"endColumn":21},{"ruleId":"72","severity":1,"message":"90","line":197,"column":9,"nodeType":"74","messageId":"75","endLine":197,"endColumn":14},{"ruleId":"72","severity":1,"message":"91","line":257,"column":7,"nodeType":"74","messageId":"75","endLine":257,"endColumn":14},{"ruleId":"86","severity":1,"message":"87","line":287,"column":19,"nodeType":"88","messageId":"89","endLine":287,"endColumn":21},{"ruleId":"72","severity":1,"message":"92","line":315,"column":12,"nodeType":"74","messageId":"75","endLine":315,"endColumn":26},{"ruleId":"72","severity":1,"message":"93","line":375,"column":15,"nodeType":"74","messageId":"75","endLine":375,"endColumn":20},{"ruleId":"72","severity":1,"message":"94","line":419,"column":11,"nodeType":"74","messageId":"75","endLine":419,"endColumn":23},{"ruleId":"95","severity":1,"message":"96","line":535,"column":12,"nodeType":"74","messageId":"97","endLine":535,"endColumn":13},"no-native-reassign",["98"],"no-negated-in-lhs",["99"],"no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'useState' is defined but never used.","'bindActionCreators' is defined but never used.","react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute","'update' is defined but never used.","'makePiece' is assigned a value but never used.","'rules' is defined but never used.","'dispatch' is assigned a value but never used.","'highlightMoves' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'moves' is assigned a value but never used.","'options' is assigned a value but never used.","'potentialMoves' is assigned a value but never used.","'check' is assigned a value but never used.","'attackedFrom' is assigned a value but never used.","no-redeclare","'i' is already defined.","redeclared","no-global-assign","no-unsafe-negation"]